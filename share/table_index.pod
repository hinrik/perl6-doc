=head1 Perl 6 table index

This is the POD version of http://www.perlfoundation.org/perl6/index.cgi?perl_6_index_tablet

=head1 AUTHORS

This POD was generated by Ahmad M. Zawawi <ahmad.zawawi@gmail.com> via the tool:
http://svn.perlide.org/padre/trunk/Padre-Plugin-Perl6/parse_perl6_table_index.pl

For authors of the original wiki place, see:
http://www.perlfoundation.org/perl6/index.cgi?action=revision_list;page_name=perl_table_index

=head1 LICENSE

Copyright (c) 2006-2009 under the same (always latest) license(s) used by the Perl 6 /src 
branch of the Pugs trunk.

=head1 Table index

=head2 C<<< ! >>>

=over

=item - logical negation, forces binary context;

=item (twigil) - twigil of private class and object variables

=item <op> (meta op) - negates (mostly comparsion operators)

=back

=head2 C<<< !! >>>

=over

=item - second Part of the ternary (conditional) operator after ??

=back

=head2 C<<< !!! >>>

=over

=item (yadda op) - yadda Operator that calles die

=back

=head2 C<<< " " >>>

=over

=item (quoting op) - double quoting, interpolate with :s, :a, :h, :f, :c, :b (all vars, functions, blocks, control chars), alias to qq//*

=back

=head2 C<<< # >>>

=over

=item - starts a comment that continues to the end of the line; works even inside regexes as (regex Metachar)

=back

=head2 C<<< #`( ) >>>

=over

=item - starts a multi line comment that continues to the end of the line or bracket, works with any combination of bracket pairs

=back

=head2 C<<< $ >>>

=over

=item (sigil) - prefix of scalar vars

=item (regex Metachar) - end of the string

=back

=head2 C<<< $$ >>>

=over

=item (regex Metachar) - end of a line

=back

=head2 C<<< $() >>>

=over

=item (conext op) - forces scalar context, alias to item()

=back

=head2 C<<< % >>>

=over

=item (sigil) - prefix of hash variables

=item (numeric op) - gives remainder of a modulo division, forces numeric context

=back

=head2 C<<< %% >>>

=over

=item (numeric op) - Bool::True if the left is evenly divisible by right value

=back

=head2 C<<< %() >>>

=over

=item (conext op) - forces hash context, alias to the hash() function

=back

=head2 C<<< & >>>

=over

=item (sigil) - sigil of the callable namespace

=item - junctive and, requires that all conditions are met

=item (regex Metachar) - match multiple patterns (AND - connection of patterns)

=back

=head2 C<<< && >>>

=over

=item (logical op) - logical and, conditonal statements, ends evaluation on the first false expression, returns boolean result

=back

=head2 C<<< ' ' >>>

=over

=item (quoting op) - simple quoting, just / and ' needs o be quoted, alias to q//

=back

=head2 C<<< () >>>

=over

=item - grouping of values (parameters)

=item (regex Metachar) - encompass a subregex/submatch

=back

=head2 C<<< * >>>

=over

=item (numeric op) - multiplies numbers and forces numeric context on parameters;

=item (term) - synonym for Inf (Whatever) in connection with a Range operator (".."); marks the end of an array in a slice operator so that negative indices access array elements relative to one beyond the final element

=item - marks as prefix slurpy arrays in signatures

=item (twigil) - secondary sigil of global variables

=back

=head2 C<<< ** >>>

=over

=item (numeric op) - raises a number to a power and forces numeric context

=item (regex Metachar) - multiplies char or group like x (strig op) outside of regex, (ha)**3 equals (hahaha)

=back

=head2 C<<< + >>>

=over

=item (conext op), (numeric op) - forces numeric context of values and adds results

=back

=head2 C<<< +& >>>

=over

=item (numeric op) - bitwise and, numeric context

=back

=head2 C<<< ++ >>>

=over

=item (prefix & suffix op) - generic autoincrement, calls internal iterator of that object, before (prefix) or after (suffix) the evaluation of the surrounding term

=back

=head2 C<<< +< >>>

=over

=item (numeric op) - shift left in numeric kontext

=back

=head2 C<<< +> >>>

=over

=item (numeric op) - shift right in numeric kontext

=back

=head2 C<<< +^ >>>

=over

=item (numeric op) - bitwise xor in numeric context

=back

=head2 C<<< +| >>>

=over

=item (numeric op) - bitwise or in numeric context

=back

=head2 C<<< , >>>

=over

=item - list generating operator

=back

=head2 C<<< - >>>

=over

=item (numeric op) - forces numeric context and subtract

=back

=head2 C<<< -- >>>

=over

=item (prefix & suffix op) - generic autodecrement, calls internal iterator of that object, before (prefix) or after (suffix) the evaluation of the surrounding term

=back

=head2 C<<< --> >>>

=over

=item - alternative syntax to type a parameter

=back

=head2 C<<< -> >>>

=over

=item - assigns a named parameter for a block (pointy block)

=back

=head2 C<<< . >>>

=over

=item - secondary sigil for public accessors (getter/setter)

=item (regex Metachar) - really any character (unlike Perl 5)

=back

=head2 C<<< .. >>>

=over

=item - range generating operator; range object in scalar context, see smartmatch table

=back

=head2 C<<< ... >>>

=over

=item (op) - infix operator for list generation

=item (yadda op) - term that calls fail (exception), marks unimplemented empty routine bodies

=back

=head2 C<<< / >>>

=over

=item (numeric op) - division, numeric context

=back

=head2 C<<< // >>>

=over

=item (numeric op) - returns the first defined value, similar to orelse

=back

=head2 C<<< : >>>

=over

=item - pair generation operator, also known as adverbial syntax

=item (filetest op) - start of all file text ops, syntax: ":" ~ one (<r w x o R W X O e z s f d l p S b c t u g k T B M A C>)

=item (twigil) - for autogenerated named parameters of a block

=item - marks as prefix named parameter in a signature

=item - (flow control) - endchar of all labels, jou can jump to (see also goto)

=back

=head2 C<<< :: >>>

=over

=item (sigil) - abstraction sigil, name space separator (like in Perl 5)

=back

=head2 C<<< ::= >>>

=over

=item - binding a value or variable to a variable at compile time

=back

=head2 C<<< := >>>

=over

=item - creates an alias to a variable at runtime (binding)

=back

=head2 C<<< :O >>>

=over

=item (filetest op) - tests if file is owned by real uid

=back

=head2 C<<< :P5 >>>

=over

=item (regex modifier) - activate old Perl 5 regex rules, alias to :Perl5

=back

=head2 C<<< :Perl5 >>>

=over

=item (regex modifier) - activate old Perl 5 regex rules, alias to :P5

=back

=head2 C<<< :R >>>

=over

=item (filetest op) - check if file is readable by real uid/gid

=back

=head2 C<<< :S >>>

=over

=item (filetest op) - file is a socket

=back

=head2 C<<< :W >>>

=over

=item (filetest op) - check if file is writeable by real uid/gid

=back

=head2 C<<< :X >>>

=over

=item (filetest op) - check if file is executable by real uid/gid

=back

=head2 C<<< :a >>>

=over

=item (quoting adverb) - demands evaluation of array variables, short form of ":array", included in "", qq and <<>>

=item (regex modifier) - no distinction between same chars with or without accent (funny symbols above), short for ":ignoreaccent"

=back

=head2 C<<< :aa >>>

=over

=item (regex modifier) - only for substitutions, replacing with chars that have the same accent pattern as the replaced, short for ":sameaccent"

=back

=head2 C<<< :array >>>

=over

=item (quoting adverb) - demands evaluation of array variables, long form of ":a", included in "", qq and <<>>

=back

=head2 C<<< :b >>>

=over

=item (filetest op) - file is a block special file (e.g. Harddisks, CDROMs and RAM areas)

=item (quoting adverb) - forces evaluation of escape sequences, short form of _":backslash", included in "", qq and <<>>

=back

=head2 C<<< :b<n> >>>

=over

=item - general radix form for literals, makes a number n in base b (up to 36), for example :2<1000001> is 65

=back

=head2 C<<< :backslash >>>

=over

=item (quoting adverb) _ - forces evaluation of escape sequences, long form of ":b", included in "", qq and <<>>

=back

=head2 C<<< :bytes >>>

=over

=item (regex modifier) - searching on byte level, (see also chars, codes, graphs)

=back

=head2 C<<< :c >>>

=over

=item (filetest op) - file is a character special file (e.g. terminals modems)

=item (quoting adverb) - forces evaluation of closures (blocks aka { ... }) inside quotes, long form of ":closure", included in "", qq and <<>>

=item (<n>) (regex modifier) - searching from nth (n is an int) position (counting from 0) and then going to the right, short for ":continue"

=back

=head2 C<<< :chars >>>

=over

=item (regex modifier) - searching on character level (default), (see also bytes, codes, graphs)

=back

=head2 C<<< :closure >>>

=over

=item (quoting adverb) - forces evaluation of closures (blocks aka { ... }) inside quotes, long form of ":c", included in "", qq and <<>>

=back

=head2 C<<< :code >>>

=over

=item (quoting adverb) - quasi quoting, the commented will be compiles and the AST will be returned as result, see also: quasi

=back

=head2 C<<< :codes >>>

=over

=item (regex modifier) - searching on codepoint level (between codepoints), (see also bytes, chars, graphs)

=back

=head2 C<<< :continue >>>

=over

=item (<n>) - (regex modifier) - searching from nth (n is an int) position (counting from 0) and then going to the right, short for ":c"

=back

=head2 C<<< :d >>>

=over

=item (filetest op) - check if file is a directory

=back

=head2 C<<< :double >>>

=over

=item (quoting adverb) - double quoting, "q" with interpolation of variables, alias to "...", qq /.../ and Q :s, :a, :h, :f, :c, :b /.../, long for ":qq"

=back

=head2 C<<< :e >>>

=over

=item (filetest op) - tests if file exists

=back

=head2 C<<< :ex >>>

=over

=item (regex modifier) - searching at all positions as long as it findes something (with backtracking), short for ":exhaustive"

=back

=head2 C<<< :exec >>>

=over

=item (quoting adverb) - quoted string will be executed and replaced with its result, alias to Q :x and qx //

=back

=head2 C<<< :exhaustive >>>

=over

=item (regex modifier) - searching at all positions as long as it findes something (with backtracking), long for ":ex"

=back

=head2 C<<< :f >>>

=over

=item (filetest op) - file is a plain file (no socket or dir, ...etc.)

=item (quoting adverb) - demands evaluation of functions (subs and methods), that start with "&" and replacing them with the result, long form of ":function", included in "", qq and <<>>

=back

=head2 C<<< :function >>>

=over

=item (quoting adverb) - demands evaluation of functions (subs and methods), that start with "&" and replacing them with the result, long form of ":f", included in "", qq and <<>>

=back

=head2 C<<< :g >>>

=over

=item (filetest op) - report if file has setgid bit set

=item (regex modifier) - searching for any finding (not just the first), short for :global

=back

=head2 C<<< :global >>>

=over

=item (regex modifier) - searching for any finding (not just the first), long for :g

=back

=head2 C<<< :graphs >>>

=over

=item (regex modifier) - searching on the level of language-independent graphemes, (see also bytes, chars, codes)

=back

=head2 C<<< :h >>>

=over

=item (quoting adverb) - demands evaluation of hash variables, long form of ":hash", included in "", qq and <<>>

=back

=head2 C<<< :hash >>>

=over

=item (quoting adverb) - demands evaluation of hash variables, long form of ":h", included in "", qq and <<>>

=back

=head2 C<<< :heredoc >>>

=over

=item (quoting adverb) - defines end marker for the following heredoc, :heredoc is equal to :to

=back

=head2 C<<< :i >>>

=over

=item (regex modifier) - uppercase and lowercase variants of a letter are taken as the same letter, short for ":ignorecase" (same as in Perl 5)

=back

=head2 C<<< :ignoreaccent >>>

=over

=item (regex modifier) - no distinction between same chars with or without accent (funny symbols above), short for ":a"

=back

=head2 C<<< :ignorecase >>>

=over

=item (regex modifier) - uppercase and lowercase variants of a letter are taken as the same letter, long for ":i" (same as in Perl 5)

=back

=head2 C<<< :ignoremark >>>

=over

=item (regex modifier) - comparing base characters (Unicode non-mark characters) while ignoring any trailing mark characters, long for ":m"

=back

=head2 C<<< :ii >>>

=over

=item (regex modifier) - only for substitutions, replacing with chars that have the same case pattern as the replaced, short for ":samecase"

=back

=head2 C<<< :k >>>

=over

=item (filetest op) - report if file has sticky bit set

=back

=head2 C<<< :keepall >>>

=over

=item (regex modifier) - forces subrules to memorize everything (even comments)

=back

=head2 C<<< :l >>>

=over

=item (filetest op) - file is a symbolic link

=back

=head2 C<<< :m >>>

=over

=item (regex modifier) - comparing base characters (Unicode non-mark characters) while ignoring any trailing mark characters, short for ":ignoremark"

=back

=head2 C<<< :mm >>>

=over

=item (regex modifier) - substitute with chars that has same mark/accent pattern as the matched string, short for ":samemark"

=back

=head2 C<<< :o >>>

=over

=item (filetest op) - tests if file is owned by effective uid

=back

=head2 C<<< :ov >>>

=over

=item (regex modifier) - searching at all positions just one time (with backtracking), short for ":overlap"

=back

=head2 C<<< :overlap >>>

=over

=item (regex modifier) - searching at all positions just one time (with backtracking), long for ":ov"

=back

=head2 C<<< :p >>>

=over

=item (filetest op) - file is a named pipe (FIFO), or filehandle is a pipe

=item (quoting adverb) - quote paths and create path object that know the right format of the current $*OS with Q :p /.../, short for :path

=item (<n>) (regex modifier) - searching only on the nth (n is an int) position (counting from 0), short for ":pos"

=back

=head2 C<<< :panic >>>

=over

=item (regex modifier) - overwriting a possible set :ratchet for all subrules (activates backtracking)

=back

=head2 C<<< :path >>>

=over

=item (quoting adverb) - quote paths and create path object that know the right format of the current $*OS with Q :path /.../, long for :p

=back

=head2 C<<< :pos >>>

=over

=item (<n>) (regex modifier) - searching only on the nth (n is an int) position (counting from 0), long for ":p"

=back

=head2 C<<< :q >>>

=over

=item (quoting adverb) - simple quoting (slashes and '), alias to '...' and q /.../, short for ":single"

=back

=head2 C<<< :qq >>>

=over

=item (quoting adverb) - double quoting, "q" with interpolation of variables, alias to "...", qq /.../ and Q :s, :a, :h, :f, :c, :b /.../, short for ":double"

=back

=head2 C<<< :quotewords >>>

=over

=item (quoting adverb) - split quoted string on words (on whitespaces) with quote protection (like in shell - '' and "" sourround words), long form of ":quotewords", used in < ... > and << ... >>

=back

=head2 C<<< :r >>>

=over

=item (filetest op) - check if file is readable by effective uid/gid

=back

=head2 C<<< :ratchet >>>

=over

=item (regex modifier) - deactivates backtracking, search starts at pos, where last match ended

=back

=head2 C<<< :regex >>>

=over

=item (quoting adverb) - parse as quoted string as regex

=back

=head2 C<<< :rw >>>

=over

=item (regex modifier) - gives the regex the right to change the string (operand)

=back

=head2 C<<< :s >>>

=over

=item (filetest op) - file has size greater than 0

=item (quoting adverb) - demands evaluation of scalar variables, long form of ":scalar", included in "", qq and <<>>

=item (regex modifier) - whitespace separates now subregex and don't stand for spaces to look for, short for ":sigspace", mm// is alias to m:sigspace//

=back

=head2 C<<< :sameaccent >>>

=over

=item (regex modifier) - only for substitutions, replacing with chars that have the same accent pattern as the replaced, long for ":aa"

=back

=head2 C<<< :samecase >>>

=over

=item (regex modifier) - only for substitutions, replacing with chars that have the same case pattern as the replaced, long for ":ii"

=back

=head2 C<<< :samemark >>>

=over

=item (regex modifier) - substitute with chars that has same mark/accent pattern as the matched string, long for ":mm"

=back

=head2 C<<< :samespace >>>

=over

=item (regex modifier) - smart space mapping for substitutions, long for ":ss", ss// is alias to s:samespace///, (ss/teh hsa/the has/;)

=back

=head2 C<<< :scalar >>>

=over

=item (quoting adverb) - demands evaluation of scalar variables, long form of ":s", included in "", qq and <<>>

=back

=head2 C<<< :sigspace >>>

=over

=item (regex modifier) - whitespace separates now subregex and don't stand for spaces to look for, long for for ":s", mm// is alias to m:sigspace//

=back

=head2 C<<< :single >>>

=over

=item (quoting adverb) - simple quoting (slashes and '), alias to '...' and q /.../, long for ":q"

=back

=head2 C<<< :ss >>>

=over

=item (regex modifier) - only for for substitution, whitespace separates subregexes like :sigspace, but also in the second part, short for ":samespace"

=back

=head2 C<<< :subst >>>

=over

=item (quoting adverb) - parse as substitution

=back

=head2 C<<< :t >>>

=over

=item (filetest op) - filehandle is opened to a tty (terminal)

=back

=head2 C<<< :to >>>

=over

=item (quoting adverb) - defines end marker for the following heredoc, :to is short for :heredoc

=back

=head2 C<<< :trans >>>

=over

=item (quoting adverb) - evals the quoted as transliteration aka tr ///

=back

=head2 C<<< :u >>>

=over

=item (filetest op) - report if file has setuid bit set

=back

=head2 C<<< :w >>>

=over

=item (filetest op) - check if file is writeable by effective uid/gid

=item (quoting adverb) - split quoted string on words (on whitespaces), no quote protection, short form of ":words", used in qw//

=back

=head2 C<<< :words >>>

=over

=item (quoting adverb) - split quoted string on words (on whitespaces), no quote protection, long form of ":w", used in qw//

=back

=head2 C<<< :ww >>>

=over

=item (quoting adverb) - split quoted string on words (on whitespaces) with quote protection (like in shell - '' and "" sourround words), short form of ":quotewords", used in < ... > and << ... >>

=back

=head2 C<<< :x >>>

=over

=item (filetest op) - check if file is executable by effective uid/gid

=item (quoting adverb) - quoted string will be executed and replaced with its result, alias to Q :exec and qx //

=item (<n>) (regex modifier) - searching n times (n is an int) with this pattern

=back

=head2 C<<< ; >>>

=over

=item - seperates commands (statements) or array indices eg @[2;3] instead of @a[2][3]

=back

=head2 C<<< < >>>

=over

=item - less than, numeric comparison operator

=back

=head2 C<<< <-> >>>

=over

=item double pointy syntax to assign a rw parameter to a block

=back

=head2 C<<< << >>>

=over

=item (meta op) - applies the operator on the left as hyper operator to the array on the right

=back

=head2 C<<< <<== >>>

=over

=item - leftward pointing feed operator that adds values to an existing list (append-mode)

=back

=head2 C<<< <<>>>"{link: [Perl 6 IO Tablet] Quote Words} --> >>>

=over

=item (quoting op) - circumfix quoting operator for grouping with autoquoting and evaluation (alias to Q :qq :ww /.../)

=back

=head2 C<<< <= >>>

=over

=item - less than or equal, numeric comparison operator

=back

=head2 C<<< <== >>>

=over

=item - leftward pointing feed operator

=back

=head2 C<<< <=> >>>

=over

=item - numeric less-equal-greater comparison for Order class

=back

=head2 C<<< <> >>>

=over

=item (regex metachar) - embraces an subrule (assertion)

=back

=head2 C<<< <>"{link: [Perl 6 IO Tablet] Quote Words} --> >>>

=over

=item (quoting op) - circumfix quoting operator for grouping with autoquoting (alias to Q :q :ww /.../ or qw/.../)

=back

=head2 C<<< <op>= >>>

=over

=item (meta op) - self assignment, left side is one oper and the result is assigned to ($a += 3; equals $a = $a + 3)

=back

=head2 C<<< <var>[] >>>

=over

=item - postcircumfix operator, appended on an array var, returns an array slice with values which indexes was inside the brackets

=back

=head2 C<<< = >>>

=over

=item (Op) - assignment, right side is evaluated and assigned to the left

=back

=head2 C<<< =:= >>>

=over

=item (comparison op) - compares binding, if both vars are bound to same memory location

=back

=head2 C<<< == >>>

=over

=item (comparison op) - equality of value (numeric)

=back

=head2 C<<< === >>>

=over

=item (comparison op) - identity, equality of value and type

=back

=head2 C<<< ==> >>>

=over

=item (Op) - rightward pointing feed operator

=back

=head2 C<<< ==>> >>>

=over

=item (Op) - rightward pointing feed operator that adds values to an existing list (append-mode)

=back

=head2 C<<< => >>>

=over

=item (comparison op) - pair (and hash) constructor, fatarrow

=back

=head2 C<<< > >>>

=over

=item (comparison op) - greater than, numeric comparison operator; ends grouping with autoquoting (formerly qw())

=back

=head2 C<<< >= >>>

=over

=item (comparison op) - greater than or equal, numeric comparison Op

=back

=head2 C<<< >> >>>

=over

=item (meta op) - binds operator (right) as hyper operator to an array (left)

=back

=head2 C<<< ? >>>

=over

=item (conext op) - forces binary context in an expression

=item - marks as postfix optional parameters in signatures

=item - quantifier for 0 or 1 occurrence in Regexes

=item (twigil) - secondary sigil for constant compiler hint variables

=back

=head2 C<<< ?& >>>

=over

=item - logical op, and combinator, forces binary context

=back

=head2 C<<< ?? !! >>>

=over

=item (logical op) - ternary or conditional operator

=back

=head2 C<<< ??? >>>

=over

=item (yadda op) - yadda operator that calles warn

=back

=head2 C<<< ?^ >>>

=over

=item - logical xor, forces operands into boolean context

=back

=head2 C<<< ?| >>>

=over

=item - logical or, forces operands into boolean context

=back

=head2 C<<< @ >>>

=over

=item (sigil) - sigil of an array

=back

=head2 C<<< @() >>>

=over

=item (conext op) - forces (flattened) array context, alias to list() function

=back

=head2 C<<< Any >>>

=over

=item (undefined value type) - Perl 6 object (default routine parameter type, excludes junction)

=back

=head2 C<<< Array >>>

=over

=item (mutable type) - Perl Array, a series of Scalar value container, or a variable that stores such a list

=back

=head2 C<<< BEGIN >>>

=over

=item "(closure trait)"{} - marks a special block or statement, executed at compile time, ASAP, only ever runs once

=back

=head2 C<<< Bag >>>

=over

=item (immutable type) - unordered collection of values that allows duplicates

=back

=head2 C<<< Bit >>>

=over

=item (immutable type) - Perl single bit (allows traits, aliasing, undef, etc.)

=back

=head2 C<<< Blob >>>

=over

=item - (immutable type) - An undifferentiated mass of bits

=back

=head2 C<<< Block >>>

=over

=item (immutable type) - Executable objects that have lexical scopes (enclosed by curly braces)

=back

=head2 C<<< Bool >>>

=over

=item (immutable type) - Perl boolean

=back

=head2 C<<< Buf >>>

=over

=item (mutable type) - Perl buffer (a stringish array of memory locations)

=back

=head2 C<<< CATCH >>>

=over

=item (closure trait) - marks a special block to catch exceptions, before LEAVE

=back

=head2 C<<< CHECK >>>

=over

=item (closure trait) - marks a special block or statement, executed at compile time, ALAP, only ever runs once

=back

=head2 C<<< CONTROL >>>

=over

=item (closure trait) - marks a special block to catch control exceptions (like next/last/return etc), before LEAVE

=back

=head2 C<<< Capture >>>

=over

=item (immutable type) - Function call arguments (right-hand side of a binding)

=back

=head2 C<<< Code >>>

=over

=item - data typ for code references of any kind  

=back

=head2 C<<< Complex >>>

=over

=item (immutable type) - Perl complex number

=back

=head2 C<<< Cool >>>

=over

=item (undefined value type) - Perl 6 Convenient OO Loopbacks,

=back

=head2 C<<< Duration >>>

=over

=item - (immutable type) - The difference between two Instants

=back

=head2 C<<< END >>>

=over

=item (closure trait) - marks a special block, executed at run time, ALAP, only ever runs once

=back

=head2 C<<< ENTER >>>

=over

=item (closure trait) - marks a special block or statement, executed at every block entry time, repeats on loop blocks

=back

=head2 C<<< Enum >>>

=over

=item (immutable type) - An immutable Pair

=back

=head2 C<<< EnumMap >>>

=over

=item (immutable type) - A mapping of Enums with no duplicate keys

=back

=head2 C<<< Exception >>>

=over

=item (immutable type) - Perl exception, errors or abnormal events interfering with normal execution, which Perl 6 can both generate and handle

=back

=head2 C<<< FIRST >>>

=over

=item (closure trait) - marks a special block or statement, executed at loop initialization time, before any ENTER

=back

=head2 C<<< Failure >>>

=over

=item (undefined value type) - data type object for an error, thrown by an unhandled exception

=back

=head2 C<<< FatRat >>>

=over

=item (immutable type) - Perl rational (unlimited precision in both parts)

=back

=head2 C<<< HOW >>>

=over

=item (introspection method) - (reserved for documentation)

=back

=head2 C<<< HardRoutine >>>

=over

=item - (immutable type) - A routine that is committed to not changing

=back

=head2 C<<< Hash >>>

=over

=item (mutable type) - Perl hash, a two column table of Scalar, values in one column are keys to refer to the values in the other column

=back

=head2 C<<< INIT >>>

=over

=item (closure trait) - marks a special block or statement, executed at run time, ASAP, only ever runs once

=back

=head2 C<<< IO >>>

=over

=item (mutable type) - Perl filehandle

=back

=head2 C<<< Inf >>>

=over

=item - infinity, to generate infinite lazy lists

=back

=head2 C<<< Instant >>>

=over

=item - (immutable type) - A point on the continuous atomic timeline

=back

=head2 C<<< Int >>>

=over

=item (immutable type) - Perl integer (allows Inf/NaN, arbitrary precision, etc.)

=back

=head2 C<<< Iterator >>>

=over

=item (mutable type) - Perl list

=back

=head2 C<<< KEEP >>>

=over

=item (closure trait) - marks a special block, executed at every successful block exit, part of LEAVE queue

=back

=head2 C<<< KeyBag >>>

=over

=item (mutable type) - KeyHash of UInt (does Bag in list/array context)

=back

=head2 C<<< KeySet >>>

=over

=item (mutable type) - KeyHash of Bool (does Set in list/array context)

=back

=head2 C<<< LAST >>>

=over

=item (closure trait) - marks a special block, executed at loop termination time, after any LEAVE

=back

=head2 C<<< LEAVE >>>

=over

=item (closure trait) - marks a special block, executed at every block exit time

=back

=head2 C<<< Macro >>>

=over

=item (mutable type) - Perl compile-time subroutine

=back

=head2 C<<< Match >>>

=over

=item (mutable type) - Perl match, usually produced by applying a pattern

=back

=head2 C<<< Method >>>

=over

=item (mutable type) - Perl method

=back

=head2 C<<< Mu >>>

=over

=item (undefined value type) - most (generic) undefined object

=back

=head2 C<<< NEXT >>>

=over

=item (closure trait) - marks a special block, executed at loop continuation time, before any LEAVE

=back

=head2 C<<< Num >>>

=over

=item (immutable type) - Perl number (approximate Real, generally via floating point)

=back

=head2 C<<< POST >>>

=over

=item (closure trait) - marks a special block, assert postcondition, executed at every block exit, after LEAVE

=back

=head2 C<<< PRE >>>

=over

=item (closure trait) - marks a special block, assert precondition, executed at every block entry, before ENTER

=back

=head2 C<<< Pair >>>

=over

=item (mutable type) - A single key-to-value association

=back

=head2 C<<< PairSeq >>>

=over

=item (mutable type) - A Seq of Pairs

=back

=head2 C<<< Parcel >>>

=over

=item - (immutable type) - Arguments in a comma list

=back

=head2 C<<< Q >>>

=over

=item (generalized quoting op) - understands a list of adverbs

=back

=head2 C<<< R >>>

=over

=item <op> (meta op) - reverse operands

=back

=head2 C<<< Range >>>

=over

=item (immutable type) - A pair of ordered endpoints

=back

=head2 C<<< RangeIter >>>

=over

=item (mutable type) - Iterator over a Range

=back

=head2 C<<< Rat >>>

=over

=item (immutable type) - Perl rational (exact Real, limited denominator)

=back

=head2 C<<< Regex >>>

=over

=item (mutable type) - Perl pattern

=back

=head2 C<<< Routine >>>

=over

=item (mutable type) - Base class for all wrappable executable objects

=back

=head2 C<<< S >>>

=over

=item <op> (meta op) - force sequential (synchronous) evaluation, suppresses any explicit or implicit parallelism

=back

=head2 C<<< START >>>

=over

=item (closure trait) - marks a special block or statement, executed on first ever execution, once per closure clone

=back

=head2 C<<< Scalar >>>

=over

=item (mutable type) - Perl scalar, variable that holds a single value

=back

=head2 C<<< Seq >>>

=over

=item (immutable type) - A list of values (can be generated lazily)

=back

=head2 C<<< SeqIter >>>

=over

=item (mutable type) - Iterator over a Seq

=back

=head2 C<<< Set >>>

=over

=item (immutable type) - unordered collection of values that allows no duplicates

=back

=head2 C<<< Signature >>>

=over

=item - (immutable type) - Function parameters (left-hand side of a binding), surrounded by round parentheses

=back

=head2 C<<< SoftRoutine >>>

=over

=item (mutable type) - A routine that is committed to staying mutable

=back

=head2 C<<< Stash >>>

=over

=item (mutable type) - A symbol table hash (package, module, class, lexpad, etc)

=back

=head2 C<<< Str >>>

=over

=item (immutable type) - Perl string (finite sequence of Unicode characters)

=back

=head2 C<<< Sub >>>

=over

=item (mutable type) - Perl subroutine object

=back

=head2 C<<< Submethod >>>

=over

=item (mutable type) - Perl subroutine acting like a method

=back

=head2 C<<< UNDO >>>

=over

=item (closure trait) - marks a special block, executed at every unsuccessful block exit, part of LEAVE queue

=back

=head2 C<<< WHAT >>>

=over

=item (introspection method) - short name of the class that an object belongs to

=back

=head2 C<<< WHEN >>>

=over

=item (introspection method) - (reserved for events?)

=back

=head2 C<<< WHENCE >>>

=over

=item (introspection method) - autovivification of closures

=back

=head2 C<<< WHERE >>>

=over

=item (introspection method) - memory address of the object

=back

=head2 C<<< WHICH >>>

=over

=item (introspection method) - object ID (type)

=back

=head2 C<<< WHO >>>

=over

=item (introspection method) - package, that support that object, long name in string context

=back

=head2 C<<< WHY >>>

=over

=item (introspection method) - (reserved for documentation)

=back

=head2 C<<< Whatever >>>

=over

=item (undefined value type) - Wildcard (like Any, but subject to do-what-I-mean via multi method dispatch)

=back

=head2 C<<< X >>>

=over

=item (list op) - Cross product of two arrays, eg 1,2 X 3,4 == 1,3,1,4,2,3,2,4 ; alias of comb method

=item <op> (meta op) - Cross product with hyper operator, eg <a b> X~ <y z> == <ay az by bz>

=back

=head2 C<<< Z >>>

=over

=item (list op) - alias to zip (list op) , joines 2 lists eg 1,2,3,4 Z 8,9 == 1,8,2,9

=item <op> (meta op) - joines the values from same position of 2 lists with following operator and produces in that manner a new list

=back

=head2 C<<< [\<op>] >>>

=over

=item (meta op) - circumfix reduction metaop, applies above reduction to a series of lists made of array slices ranging in length from 1 to the complete length of the original list

=back

=head2 C<<< [] >>>

=over

=item - circumfix operator that creates a reference to an array that holds all values that encompas these brackets

=item (meta op) - circumfix reduction metaop, close to functional "reduce", applies the operator between all elements of an array

=back

=head2 C<<< \ >>>

=over

=item - capture generator, creates a reference to the following structure

=item - escape char, all escape sequences inside quotes and regexes start with it

=back

=head2 C<<< \0[<n>] >>>

=over

=item escape sequence - character given in octal (brackets optional)

=back

=head2 C<<< \B >>>

=over

=item escape sequence - Match when not on a word boundary

=back

=head2 C<<< \C[<n>] >>>

=over

=item escape sequence - any character except the bracketed named or control character

=back

=head2 C<<< \D >>>

=over

=item escape sequence - nondigit

=back

=head2 C<<< \E >>>

=over

=item escape sequence - anything but an escape character

=back

=head2 C<<< \F >>>

=over

=item escape sequence - anything but form feed

=back

=head2 C<<< \H >>>

=over

=item (escape sequence) - anything but horizontal whitespace

=back

=head2 C<<< \L[<n>] >>>

=over

=item escape sequence - everything within the brackets is lowercase

=back

=head2 C<<< \N >>>

=over

=item escape sequence - anything but (logical) newline

=back

=head2 C<<< \Q[<n>] >>>

=over

=item escape sequence - all metacharacters within the brackets match as literal characters

=back

=head2 C<<< \R >>>

=over

=item escape sequence - anything but return

=back

=head2 C<<< \S >>>

=over

=item escape sequence - anything but whitespace

=back

=head2 C<<< \T >>>

=over

=item escape sequence - anything but a tab

=back

=head2 C<<< \U[<n>] >>>

=over

=item escape sequence - everything within the brackets is uppercase

=back

=head2 C<<< \V >>>

=over

=item escape sequence - anything but vertical whitespace

=back

=head2 C<<< \W >>>

=over

=item escape sequence - anything but a word character

=back

=head2 C<<< \X[<n>] >>>

=over

=item escape sequence - anything but the character given in hexadecimal (brackets optional)

=back

=head2 C<<< \b >>>

=over

=item escape sequence - word boundary

=back

=head2 C<<< \c[<n>] >>>

=over

=item escape sequence - named character or control character

=back

=head2 C<<< \d >>>

=over

=item escape sequence - digit

=back

=head2 C<<< \e >>>

=over

=item escape sequence - escape character

=back

=head2 C<<< \f >>>

=over

=item escape sequence - form feed

=back

=head2 C<<< \h >>>

=over

=item (escape sequence) - horizontal whitespace

=back

=head2 C<<< \n >>>

=over

=item escape sequence - (logical) newline

=back

=head2 C<<< \r >>>

=over

=item escape sequence - return (CR), as in Perl 5

=back

=head2 C<<< \s >>>

=over

=item escape sequence - any whitespace character (\h or \v or \t)

=back

=head2 C<<< \t >>>

=over

=item escape sequence - tab, not visible character

=back

=head2 C<<< \v >>>

=over

=item escape sequence - vertical whitespace

=back

=head2 C<<< \w >>>

=over

=item escape sequence - word character (Unicode alphanumeric plus "_")

=back

=head2 C<<< \x[<n>] >>>

=over

=item escape sequence - character given in hexadecimal (brackets optional)

=back

=head2 C<<< ^ >>>

=over

=item - junctive xor, requires that one value in a list is true

=item - upto operator, ^$limit expands to 0 ..^ +$limit range

=item - in range definitions, it excludes a limit value, in scalar context see smartmatch

=item (twigil) - for autogenerated positional parameters of a block, position results from alphabetical order of all $^-Variables

=item (regex Metachar) - start of the string

=back

=head2 C<<< ^^ >>>

=over

=item - logical xor, combines expressions, returns true when only one expression is true, otherwise false

=item (regex Metachar) - start of a line

=back

=head2 C<<< abs >>>

=over

=item (numeric op) - returns numeric absolute value

=back

=head2 C<<< after >>>

=over

=item (comparison op) - generic comparison operator used by the Order class, true if left should follow right

=back

=head2 C<<< all >>>

=over

=item - junctive AND operator

=back

=head2 C<<< and >>>

=over

=item - logical AND operator

=back

=head2 C<<< andthen >>>

=over

=item - logical AND short circuit operator, transferring $_ from first to second block/command, if first do succeed

=back

=head2 C<<< anon >>>

=over

=item (scope declarator) - introduces names that aren't to be stored anywhere (anonymous)

=back

=head2 C<<< any >>>

=over

=item - junctive OR operator

=back

=head2 C<<< array() >>>

=over

=item (conext op) - forces array context, alias to @()

=back

=head2 C<<< as >>>

=over

=item (string method) - converts like sprintf

=item (routine trait) - inner type constraint that a routine imposes on its return value

=back

=head2 C<<< assoc >>>

=over

=item (routine trait) - specifies the associativity of an operator explicitly

=back

=head2 C<<< assuming >>>

=over

=item - method of all subroutine reference objects that enables Currying

=back

=head2 C<<< async >>>

=over

=item (block modifier) - allows the interpreter to parallelize the following

=back

=head2 C<<< augment >>>

=over

=item (scope declarator) - adds definitions to an existing name, inserts new methods and attributes into a class/grammar or replaces them

=back

=head2 C<<< before >>>

=over

=item (comparison op) - generic comparison operator used by the Order class, true when left should precede right

=back

=head2 C<<< break >>>

=over

=item (flow control) - leave this when clause block now

=back

=head2 C<<< but >>>

=over

=item - alters properties of a variable at run time

=back

=head2 C<<< bytes >>>

=over

=item (string method) - returns number of bytes used (a sort of length)

=back

=head2 C<<< cached >>>

=over

=item (routine trait) - marks a subroutine as being memoized

=back

=head2 C<<< call >>>

=over

=item - execute a subroutine

=back

=head2 C<<< caller >>>

=over

=item - object describing the code from which as routine was invoked

=back

=head2 C<<< callwith >>>

=over

=item - submethode by which one can call a sub with a different signature

=back

=head2 C<<< capitalize >>>

=over

=item - alias to a wordwise ucirst(lc($_)), makes first char of every word upper case, rest lowercase

=back

=head2 C<<< cat >>>

=over

=item (array method) - coverts values of a list into string context and joines them like with '~', alias to .join('')

=back

=head2 C<<< category >>>

=over

=item (grammatical category) - namespace of grammatical categories, in case you want to create a new one with a macro

=back

=head2 C<<< char >>>

=over

=item (num method) - convert number into charakter according a character table, reverse of ord

=back

=head2 C<<< chars >>>

=over

=item (string method) - returns number of characters  

=back

=head2 C<<< chdir >>>

=over

=item - changes the current working directory ($*CWD)

=back

=head2 C<<< chmod >>>

=over

=item - changes access rights of files

=back

=head2 C<<< chomp >>>

=over

=item (string method) - returns a string with the last newline (if there is one) removed

=back

=head2 C<<< chop >>>

=over

=item (string method) - returns a string with the last character removed

=back

=head2 C<<< chown >>>

=over

=item - changes owner of files

=back

=head2 C<<< circumfix >>>

=over

=item (grammatical category) - operator namespace of ops, that stay after one statement or variable, but do surround a second (like braces in $a[2])

=back

=head2 C<<< class >>>

=over

=item (block modifier) - declares a collection of methods that define an object

=back

=head2 C<<< classify >>>

=over

=item (array method) - special form of map, to classify input values; the return value of the closure determines, under which key the value appears in the resulting hash

=back

=head2 C<<< close >>>

=over

=item (filehandle method) - releasing the connection to a file via a file handler

=back

=head2 C<<< cmp >>>

=over

=item (comp op) - compares values textually, gives results -1(lower than), 0 (equal), 1 (greater than), using the Order class

=back

=head2 C<<< comb >>>

=over

=item (string method) - $str.comb(/pattern/) equals $str ~~ m:g/pattern/, except it returns the list of findings, not a match object like .match aka m//; default pattern is rx/./

=back

=head2 C<<< constant >>>

=over

=item (var trait) - makes so declared var (is constant) a real constant

=back

=head2 C<<< contend >>>

=over

=item (block modifier) - marks a block as atomic, concurrent proceses have to wait

=back

=head2 C<<< continue >>>

=over

=item (flow control) - makes execution in a 'given' also try the following 'when' clauses

=back

=head2 C<<< copy >>>

=over

=item (parameter trait) - read-writable copy of the original argument ("pass-by-value")

=back

=head2 C<<< cross >>>

=over

=item (list method) - alias to X operator:  @a X @b = (@a; @b).cross 

=back

=head2 C<<< crosswith >>>

=over

=item (list method) - alias to X metaoperator:  @a X~ @b = (@a; @b).crosswith(&[~]) = (@a; @b).cross.slice.map { .reduce(&[~]) } 

=back

=head2 C<<< default >>>

=over

=item (block modifier) - following block will be executed if no when clause in surrounding block matched

=back

=head2 C<<< defer >>>

=over

=item (block modifier) -

=back

=head2 C<<< defined >>>

=over

=item - scalar method tests whether a value has been assigned to a variable

=back

=head2 C<<< delete >>>

=over

=item - removes a key and value from a hash

=back

=head2 C<<< die >>>

=over

=item - stop the program now and print a message on $*ERR

=back

=head2 C<<< dim >>>

=over

=item - array dimensioning

=back

=head2 C<<< div >>>

=over

=item - division, creates fraction objects in Integer context

=back

=head2 C<<< do >>>

=over

=item - executes a block (do once loop)

=back

=head2 C<<< does >>>

=over

=item - checks if an objekt inherits this role

=back

=head2 C<<< dynamic >>>

=over

=item (parameter trait) - parameter is an "environmental" variable, a lexical in the dynamic scope

=back

=head2 C<<< each >>>

=over

=item - variant of all() that promises to do things in order, is Positional/Iterable

=back

=head2 C<<< eager >>>

=over

=item - forces eager evaluation (now), default for scalars

=back

=head2 C<<< elems >>>

=over

=item (array method) - returns number of elements

=back

=head2 C<<< else >>>

=over

=item (block modifier) - introduces the alternative block after an 'if' or 'elsif'

=back

=head2 C<<< elsif >>>

=over

=item (block modifier) - alternative if clause

=back

=head2 C<<< enum >>>

=over

=item - creates a set

=back

=head2 C<<< eq >>>

=over

=item - equal, string comparison

=back

=head2 C<<< equiv >>>

=over

=item (routine trait) - specifies the precedence of an operator same as an existing operator

=back

=head2 C<<< eqv >>>

=over

=item - compares the dynamic state of objects and values, in contrast with static ===

=back

=head2 C<<< err >>>

=over

=item (logical operator) - returns the first defined value from the left

=back

=head2 C<<< eval >>>

=over

=item - just evaluates a string as a program and returns result and maybe error message in @!, second optional parameter defines a parser grammar which should understand the string

=back

=head2 C<<< evalfile >>>

=over

=item - behaves like, and replaces Perl 5 do EXPR, with optional $lang support

=back

=head2 C<<< exists >>>

=over

=item - checks for existence of a variable or hash member, scalar method

=back

=head2 C<<< exit >>>

=over

=item - stops all program execution, and returns Int $status (first parameter) to the calling environment

=back

=head2 C<<< fail >>>

=over

=item - a return call (end this routine) that throws an exception

=back

=head2 C<<< false >>>

=over

=item - boolean value aka Bool::False

=back

=head2 C<<< ff >>>

=over

=item - flip flop operator in the style of awk, formerly .. in scalar context

=back

=head2 C<<< fff >>>

=over

=item - flip flop operator in the style of sed, formerly ... in scalar context

=back

=head2 C<<< flip >>>

=over

=item (string method) - reverses order of characters in strings

=back

=head2 C<<< fmt >>>

=over

=item - method on a scalar, takes a format specifier returns a string, simplified sprintf

=back

=head2 C<<< for >>>

=over

=item (loop block modifier) - only iterates over a list

=back

=head2 C<<< gather >>>

=over

=item (block modifier) - performs the following block once, returns a list of all values passed by 'take'

=back

=head2 C<<< ge >>>

=over

=item (comparison op) - greater than on equal, string comparison

=back

=head2 C<<< get >>>

=over

=item (handle method) - returns a line (item context) or all lines (list context) from that input stream

=back

=head2 C<<< given >>>

=over

=item (block modifier) - case construct puts a value into the context variable for when clauses

=back

=head2 C<<< goto >>>

=over

=item (flow control) - transfer execution to a defined label

=back

=head2 C<<< grammar >>>

=over

=item - special kind of class to hold regex token and rule definitions

=back

=head2 C<<< grep >>>

=over

=item (array op & method) - gives all values of an array that pass a filters condition

=back

=head2 C<<< gt >>>

=over

=item (comparison op) - greater than or equal, string comparison, Bool::True if alphabetically ordered the right comes before the left

=back

=head2 C<<< handles >>>

=over

=item - delegates execution of a function to another method

=back

=head2 C<<< has >>>

=over

=item (scope declarator) - introduces attribute names

=back

=head2 C<<< hash >>>

=over

=item (conext op) - enforces hash-list context, alias to %()

=back

=head2 C<<< hyper >>>

=over

=item - forces none-lazy list context, that ignores the order of results (allowes parallel computing)

=back

=head2 C<<< if >>>

=over

=item (block modifier) - flow control conditional statement or block modifier, executes code only when a condition expression evaluates to true

=back

=head2 C<<< index >>>

=over

=item (string method) - finds the first occurrence of a substring in a string and returns the numerical position, opposite or rindex

=back

=head2 C<<< infix >>>

=over

=item (grammatical category) - operator namespace of ops, that are surrounded by whitespace (\w) between 2 vars or statements ($a + $b)

=back

=head2 C<<< inline >>>

=over

=item (sub trait) -

=back

=head2 C<<< int >>>

=over

=item - extract a whole number value, discarding fractional part

=back

=head2 C<<< invert >>>

=over

=item (hash op & method) - inverts the key => value relation of a pair or a series of pairs (hash)

=back

=head2 C<<< is >>>

=over

=item - bind a traits to a variable

=back

=head2 C<<< item() >>>

=over

=item (conext op) - forces scalar context, alias to $()

=back

=head2 C<<< join >>>

=over

=item (array op & method) - concatenates list elements into a string, optionally inserting another string between the elements

=back

=head2 C<<< key >>>

=over

=item (pair method) - gives the key part of a pair

=back

=head2 C<<< keys >>>

=over

=item (hash method) - returns list of hash keys

=back

=head2 C<<< kv >>>

=over

=item (hash method) - returns list of key-value pairs

=back

=head2 C<<< last >>>

=over

=item (flow control) - exit the current looping block

=item (array method) - number of final element

=back

=head2 C<<< lazy >>>

=over

=item - forces lazy evaluation (as late as possible)

=back

=head2 C<<< lc >>>

=over

=item (string op & method) - make string lowercase

=back

=head2 C<<< lcfirst >>>

=over

=item (string op & method) - make first char of a string lowercase

=back

=head2 C<<< le >>>

=over

=item (comparison op) - lower than or equal, string comparison (see lt, gt, ge)

=back

=head2 C<<< leave >>>

=over

=item (flow control) - exit the current block with a return value

=back

=head2 C<<< leg >>>

=over

=item (comparison op) - lower/equal/greater comparator for text

=back

=head2 C<<< let >>>

=over

=item - changes value of a variable temporary, it will be set back if the current block exits unsuccessfully

=back

=head2 C<<< lines >>>

=over

=item (string method) - returns a chomped list of lines (chunks of character separated by \n) containing a string,  $str.lines($limit) equals $input.comb( / ^^ \N* /, $limit ) 

=item (path method) - reads a file and returns content as array of lines

=item (io op) - returns an lazy iterator over all chomped lines of that input stream

=back

=head2 C<<< lol >>>

=over

=item (conext op) - forces list of list context on a value, meaning a list which values are not contextualized further (can be lists themthelves), opposite of a flattened list

=back

=head2 C<<< loop >>>

=over

=item (loop block modifier) - general flow control command for repetition

=back

=head2 C<<< looser >>>

=over

=item (routine trait) - specifies the precedence of an operator lower than an existing operator

=back

=head2 C<<< lt >>>

=over

=item (comparison op) - lower than, string comparison, Bool::True if alphabetically ordered the left comes before the right

=back

=head2 C<<< m >>>

=over

=item (regex quoting op) - perform a regex based search in place ( stands for match ), similar to rx (quote regex op)

=back

=head2 C<<< macro >>>

=over

=item - define a routine to alter source code at compile time

=back

=head2 C<<< map >>>

=over

=item (array op & method) - take a list, perform a block on each member, return a list of the results Arraymethode

=back

=head2 C<<< match >>>

=over

=item (string method) - method alias to m//, $str.match( /pat/ ) equals $str ~~ s/pat/;, returns a match object

=back

=head2 C<<< max >>>

=over

=item (array op & method) - returns the numerically largest value from a given list

=back

=head2 C<<< maybe >>>

=over

=item (block modifier) -

=back

=head2 C<<< method >>>

=over

=item - defines a method (inheritable routine) in a class

=back

=head2 C<<< min >>>

=over

=item (array op & method) - returns the numerically smallest value from a given list

=back

=head2 C<<< minmax >>>

=over

=item (array op & method) - returns the highest and lowest values from a list, as a 2 item list

=back

=head2 C<<< mod >>>

=over

=item (numeric op) - generic modulo operator

=back

=head2 C<<< module >>>

=over

=item (block modifier) - introduces a module name, a package that performs special actions on loading

=back

=head2 C<<< ms >>>

=over

=item (regex quoting op) - perform a regex based search in place, spaces are just subrule separators, alias to m:s/.../ or m:sigspace /.../

=back

=head2 C<<< multi >>>

=over

=item routine modifier - marks routines with can have sibling with same name but different signature, when called, the one with matching sig is executed (multimethod dispatch)

=back

=head2 C<<< my >>>

=over

=item (scope declarator) - introduces lexically scoped names, which exists only in the current scope (usually a block)

=back

=head2 C<<< new >>>

=over

=item - creates a new object of a class, also name of the automatically called constructor method

=back

=head2 C<<< next >>>

=over

=item (flow control) - start the the next following loop iteration

=back

=head2 C<<< none >>>

=over

=item - return true when a value is not part of a set, junctive NOT operator

=back

=head2 C<<< normalize >>>

=over

=item - (string method) - normalize (repair) Unicode (UTF) string

=back

=head2 C<<< not >>>

=over

=item - logical NOT operator, negates truth value, alternative to ! with lower precedence

=back

=head2 C<<< of >>>

=over

=item (routine trait) - inner type constraint that a routine imposes on its return value, eg subset Month of Int where { 1 <= $^a <= 12 }

=back

=head2 C<<< one >>>

=over

=item - junctive XOR operator

=back

=head2 C<<< only >>>

=over

=item routine modifier - permits only one routine of the same name in this block

=back

=head2 C<<< open >>>

=over

=item (filehandle method) - establishes a connection to a file via a file handler

=back

=head2 C<<< or >>>

=over

=item - logical OR operator

=back

=head2 C<<< ord >>>

=over

=item (string method) - convert charakter into number according a character table, reverse of char

=back

=head2 C<<< orelse >>>

=over

=item - logical OR short circuit operator, transferring an Error code from first to second block/command, if first do not succeed, similar to //

=back

=head2 C<<< our >>>

=over

=item (scope declarator) - introduces package - scoped names

=back

=head2 C<<< pack >>>

=over

=item - repackage values into or from a condensed format

=back

=head2 C<<< package >>>

=over

=item (block modifier) - defines this Block or File as namespace (almost like in Perl 5), some uses are now better to do with "module" and "class"

=back

=head2 C<<< pair >>>

=over

=item (context op) - force pair context

=back

=head2 C<<< pairs >>>

=over

=item (hash method) - returns all contents as an array or pairs (key,value)

=back

=head2 C<<< parcel >>>

=over

=item (parameter trait) - raw reference, will not be contextualized

=back

=head2 C<<< parsed >>>

=over

=item (routine trait) - this macro will be parsed once, it is hygienic, but own and later defined rules can't be applied, opposite of reparsed

=back

=head2 C<<< perl >>>

=over

=item - evaluates the following string or content of the var on which is called this method, functions with "say" like a better Data::Dumper

=back

=head2 C<<< pick >>>

=over

=item (array op & method) - select a number of random vaues

=item (array method) - selects randomly elements from this list, optional parameter says how many

=back

=head2 C<<< pop >>>

=over

=item (array op & method) - removes and returns the last element in an array

=back

=head2 C<<< postcircumfix >>>

=over

=item (grammatical category) - operator namespace of ops, that stay after one statement or variable, but do surround a second (like braces in $a[2])

=back

=head2 C<<< postfix >>>

=over

=item (grammatical category) - operator namespace of ops, that stay after a statement or variable (like $a++)

=back

=head2 C<<< prefix >>>

=over

=item (grammatical category) - operator namespace of ops, that stay before a statement or variable (like ++$a)

=back

=head2 C<<< print >>>

=over

=item - sends characters to an output stream without adding a newline, see 'say'

=back

=head2 C<<< printf >>>

=over

=item - formats text and sends it to standard output

=back

=head2 C<<< prompt >>>

=over

=item - "print"ing text and reading the answer (a line from $*IN - formerly STDIN)

=back

=head2 C<<< proto >>>

=over

=item routine modifier - fallback for multi, if no multi routines signature matches the callers, a proto with same name is executed

=back

=head2 C<<< push >>>

=over

=item (array op & method) - appends a list of values to the end of an array

=back

=head2 C<<< q >>>

=over

=item (quoting op) - simple quoting (slashes and '), alias to '...' and Q :q /.../ and Q :single /.../

=back

=head2 C<<< qq >>>

=over

=item (quoting op) - double quoting, "q" with interpolation of variables, alias to "..." and Q :s, :a, :h, :f, :c, :b /.../ and Q :qq // and Q :double //

=back

=head2 C<<< quasi >>>

=over

=item (block modifier) - quasi quoting, the commented will be compiles and the AST will be returned as result, see also: code

=back

=head2 C<<< quote >>>

=over

=item (grammatical category) - operator namespace, used to define new quoting ops with a macro

=back

=head2 C<<< quote_mod >>>

=over

=item (grammatical category) - operator namespace, used to define new quoting adverbs

=back

=head2 C<<< qw >>>

=over

=item (quoting op) - splits result on words (as in P5), alias to Q :q :w /.../ or <...>

=back

=head2 C<<< qx >>>

=over

=item (quoting op) - execute as command and return results (as in P5), alias to Q :x //

=back

=head2 C<<< rand >>>

=over

=item - generate a floating point random number between 0.0 and 1.0

=back

=head2 C<<< readline >>>

=over

=item - now called 'get', reads from an input stream until the next newline

=back

=head2 C<<< readonly >>>

=over

=item (parameter trait) - immutable parameter

=back

=head2 C<<< redo >>>

=over

=item (flow control) - re-starts processing of the current loop turn

=back

=head2 C<<< reduce >>>

=over

=item (list method) - alias to [ ] metaoperator:  [+] @a = @a.reduce(&[+]) 

=back

=head2 C<<< regex >>>

=over

=item - (routine type) - a pattern definition (without :ratchet and :sigspace), can be put in a grammar, similar to qr/.../ in Perl 5

=back

=head2 C<<< reparsed >>>

=over

=item (routine trait) - after parsing this macro, it will be reparsed, so that not hygienic, but its own and later defined rules can be applied, opposite of "parsed"

=back

=head2 C<<< repeat >>>

=over

=item (loop block modifier) - initial command for while or until loops that have their condtion at the end

=back

=head2 C<<< return >>>

=over

=item (flow control) - leaves a subroutine and sets the return value

=back

=head2 C<<< returns >>>

=over

=item - sub trait describing the type of value produced by a function

=back

=head2 C<<< reverse >>>

=over

=item (array op & method) - returns all the members in the opposite order. Use "flip" to turn a string back to front and "invert" for hashes

=back

=head2 C<<< rindex >>>

=over

=item (string method) - finds the last occurrence of a substring in a string and returns the numerical position, opposite or index

=back

=head2 C<<< role >>>

=over

=item - container for methods that can extend a class using does

=back

=head2 C<<< roll >>>

=over

=item (array method) - selects $n (first parameter) values from an array, duplication can occur (like rolling dice)

=back

=head2 C<<< roundrobin >>>

=over

=item (array method) - kind of zip that ignores empty values: roundrobin([1..3],[1,2],[1]) = 1,1,1,2,2,3

=back

=head2 C<<< rule >>>

=over

=item - alias for "regex :ratchet :sigspace" in a grammar, see regex, token

=back

=head2 C<<< rw >>>

=over

=item (routine trait) - marks a subroutine as returning an lvalue

=item (parameter trait) - mutable parameter (rw stands for: read write)

=back

=head2 C<<< rx >>>

=over

=item (regex quoting op) - creates anonymous regex, that can me then assigned into a var, alias to Q :regex // and regex (block modificator)

=back

=head2 C<<< s >>>

=over

=item (regex quoting op) - perform a substitution based on rx-matches in place, creates anonymous regex, alias to Q :subst // and subst (block modificator)

=back

=head2 C<<< say >>>

=over

=item - a function like print that also appends a newline (\n)

=back

=head2 C<<< seed >>>

=over

=item - initialize a random number generator, optionally with a value

=back

=head2 C<<< sigil >>>

=over

=item (grammatical category) - word to name the namespace for sigils, used to redifine them or define your own with a macro

=back

=head2 C<<< signature >>>

=over

=item (routine trait) - signature of a subroutine. Normally declared implicitly, by providing a parameter list and/or return type

=back

=head2 C<<< sleep >>>

=over

=item - Attempt to sleep for up to Num $for seconds (with sub-second resolution)

=back

=head2 C<<< slurp >>>

=over

=item (path method) - reads an entire file into a string without a file handle

=back

=head2 C<<< special_variable >>>

=over

=item (grammatical category) - namespace to define and redefine special variables with a macro

=back

=head2 C<<< splice >>>

=over

=item (array op & method) - remove on $pos (first parameter) $n (second - optional) values and replace them with values (third - optional)

=back

=head2 C<<< split >>>

=over

=item - makes an array of substrings from a string and a separator

=back

=head2 C<<< sprintf >>>

=over

=item - inserts formated values out of variables into a string like printf, but returns the string instead of outputting it

=back

=head2 C<<< ss >>>

=over

=item (regex quoting op) - performs rx based substitution, spaces are just subrule separators, alias to s:samespace/.../.../, e.g.: ss/teh hsa/the has/;

=back

=head2 C<<< state >>>

=over

=item (scope declarator) - introduces lexically scoped but persistent names (known only in the enclosing block, but retain their values between invocations)

=back

=head2 C<<< sub >>>

=over

=item (block modifier) - defines a subroutine

=back

=head2 C<<< submethod >>>

=over

=item (block modifier) - defines methods, not inherited by subclasses

=back

=head2 C<<< subset >>>

=over

=item - define a subtype, eg subset Month of Int where { 1 <= $^a <= 12 }

=back

=head2 C<<< subst >>>

=over

=item (string method) - method alias to s///, $str.subst( /pat/, "replacement" ) equals $str ~~ s/pat/"replacement/;

=back

=head2 C<<< substr >>>

=over

=item (string method) - the scalar substring function like in Perl 5

=back

=head2 C<<< supersede >>>

=over

=item (scope declarator) - replaces definitions of an existing name, e.g. methods and attributes of a class/grammar

=back

=head2 C<<< take >>>

=over

=item - produces a return value in a gather block

=back

=head2 C<<< temp >>>

=over

=item - defines variables as temporary, synonym for the Perl 5 "local"

=back

=head2 C<<< term >>>

=over

=item (grammatical category) - namespace of terms, used to redifine them or make a new with a macro

=back

=head2 C<<< tighter >>>

=over

=item (routine trait) - specifies the precedence of an operator higher than an existing operator

=back

=head2 C<<< token >>>

=over

=item - kind of regex :ratchet (no backtracking), part of a grammar

=back

=head2 C<<< touch >>>

=over

=item (filehandle method) - update timestamps on a file

=back

=head2 C<<< tr >>>

=over

=item (quoting op) - transliteration (as in Perl 5), translating some character in a string into others, alias to Q :trans ///

=back

=head2 C<<< trans >>>

=over

=item (string method) - method name for tr/// operation, $str.trans( %mapping ) equals $str ~~ tr/%mapping.sort.keys/%mapping.sort.values/;

=back

=head2 C<<< triangle >>>

=over

=item (list method) - alias to [\ ] metaoperator:  [\+] @a = @a.triangle(&[+]) 

=back

=head2 C<<< true >>>

=over

=item (term) - converts value into the boolean context, low precedence alternative to "?"

=item - boolean value aka Bool::True

=back

=head2 C<<< trusts >>>

=over

=item - allows a class the acess to otherwised sealed namespaces

=back

=head2 C<<< twigil >>>

=over

=item (grammatical category) - word to name the namespace for twigils, used to redifine them or define your own with a macro

=back

=head2 C<<< uc >>>

=over

=item - make all string chars uppercase

=back

=head2 C<<< ucfirst >>>

=over

=item - make first char of a string uppercase

=back

=head2 C<<< unless >>>

=over

=item (block modifier) - flow control modifier, opposite of if, runs block if expression is false

=back

=head2 C<<< until >>>

=over

=item (block modifier) - opposite of while, runs block repeatedly is long as expression is false

=back

=head2 C<<< unwrap >>>

=over

=item - remove an enclosing subroutine

=back

=head2 C<<< use >>>

=over

=item - load a module, import definitions, check Perl version

=back

=head2 C<<< value >>>

=over

=item (pair method) - gets value (second) value of a pair

=back

=head2 C<<< values >>>

=over

=item (hash method) - returns an array of just the values

=back

=head2 C<<< want >>>

=over

=item - produces a signature object that provides information about the context from which the current routine was called

=back

=head2 C<<< warn >>>

=over

=item - prints a message on $*ERR

=back

=head2 C<<< when >>>

=over

=item (block modifier) - executes its code block if a 'given' value smartmatches

=back

=head2 C<<< where >>>

=over

=item - defines subtypes of data, eg subset Month of Int where { 1 <= $^a <= 12 }_

=back

=head2 C<<< while >>>

=over

=item (loop block modifier) - flow control modifier runs block repeatedly as long as en expression is true

=back

=head2 C<<< will do >>>

=over

=item (routine trait) - block of code executed when the subroutine is called. Normally declared implicitly, by providing a block after the subroutine's signature definition

=back

=head2 C<<< words >>>

=over

=item (string method) - returns a list of words (chunks of alphanumeric character) containing a string,  $input.words($limit) equals $input.comb( / \S+ /, $limit ) 

=back

=head2 C<<< wrap >>>

=over

=item - creates enveloping subroutine

=back

=head2 C<<< x >>>

=over

=item (scalar string op) - string replicate operator to single string, eg 'ab' x 3 == 'ababab'

=back

=head2 C<<< xor >>>

=over

=item (scalar bool op) - boolean exclusive or operator, only true if only one operand is true

=back

=head2 C<<< xx >>>

=over

=item (scalar string op) - string replicate operator to array, eg 'ab' xx 3 == <ab ab ab>

=back

=head2 C<<< zip >>>

=over

=item (array op & method) - zip operator, joines 2 lists, alias to Z operator  @a Z @b = (@a; @b).zip 

=back

=head2 C<<< zipwith >>>

=over

=item (list method) - alias to Z metaoperator:  @a Z~ @b = (@a; @b).zipwith(&[~]) = (@a; @b).zip.slice.map { .reduce(&[~]) } 

=back

=head2 C<<< {} >>>

=over

=item - circumfix operator: encloses blocks and creates a coderef, or a hashref when it is identified as a hash or contains a '=>'

=back

=head2 C<<< | >>>

=over

=item (junctive op) - junctive or, requires that a condition is fulfilled

=item (regex Metachar) - match alternate patterns (OR - connection of patterns)

=back

=head2 C<<< |() >>>

=over

=item (conext op) - flatten capture object into arglist

=back

=head2 C<<< || >>>

=over

=item (logical op) - logical or, evaluates sequentially, ends evaluation at the first expression that returns true

=back

=head2 C<<< ||() >>>

=over

=item (conext op) - flatten capture object into semicolon list

=back

=head2 C<<< ~ >>>

=over

=item (conext op), (string op) - forces string context (stringify) and/or concatenate strings, synonym for cat

=back

=head2 C<<< ~& >>>

=over

=item - characterwise and, forces string context

=back

=head2 C<<< ~< >>>

=over

=item - characterwise left shift, forces string context

=back

=head2 C<<< ~> >>>

=over

=item - characterwise right shift, forces string context

=back

=head2 C<<< ~^ >>>

=over

=item - characterwise xor, forces string context

=back

=head2 C<<< ~| >>>

=over

=item - characterwise or, forces string context

=back

=head2 C<<< ~~ >>>

=over

=item - smartmatch operator, compares (almost) all variable and data types

=back

